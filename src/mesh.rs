use glam::Vec3;
use std::{
    path::Path,
    io::{ BufWriter, Write },
    fs::File,
    writeln,
};
use ahash::AHashMap;
use ordered_float::NotNan;

//#[cfg(feature = "multi-thread")]
//use rayon::prelude::*;

#[derive(Debug, Clone)]
pub enum Normals {
    Vertex(Vec<Vec3>),
    Face(Vec<Vec3>),
}

impl Normals {
    pub fn normals(&self) -> &Vec<Vec3> {
        let (Self::Vertex(normals) | Self::Face(normals)) = self;
        normals
    }

    pub fn into_normals(self) -> Vec<Vec3> {
        let (Self::Vertex(normals) | Self::Face(normals)) = self;
        normals
    }
}

#[derive(Debug, Clone)]
pub struct UnindexedMesh {
    pub faces: Vec<[Vec3; 3]>,
    pub normals: Option<Normals>,
}

#[derive(Debug, Clone)]
pub struct IndexedMesh {
    pub verts: Vec<Vec3>,
    pub faces: Vec<[usize; 3]>,
    pub normals: Option<Normals>,
}

impl UnindexedMesh {
    pub fn index(self) -> IndexedMesh {

        #[derive(Hash, PartialEq, Eq)]
        struct NotNanVec3 {
            pub x: NotNan<f32>,
            pub y: NotNan<f32>,
            pub z: NotNan<f32>,
        }

        impl From<Vec3> for NotNanVec3 {
            fn from(value: Vec3) -> Self {
                Self {
                    x: NotNan::new(value.x).unwrap(),
                    y: NotNan::new(value.y).unwrap(),
                    z: NotNan::new(value.z).unwrap(),
                }
            }
        }

        impl NotNanVec3 {
            fn vec3(self) -> Vec3 {
                Vec3 {
                    x: *self.x,
                    y: *self.y,
                    z: *self.z,
                }
            }
        }

        let mut index_map: AHashMap<NotNanVec3, usize> = Default::default();
        let mut face_indices: Vec<[usize; 3]> = Vec::with_capacity(self.faces.len());
        self.faces.into_iter().for_each(|face_verts| {
            let face = face_verts.map(|vert| {
                let size = index_map.len();
                *index_map.entry(vert.into()).or_insert(size)
            });
            face_indices.push(face);
        });

        let normals = {
            use Normals::*;
            if let Some(Vertex(normals)) = self.normals {
                let mut new_normals = Vec::with_capacity(index_map.len());
                new_normals.resize(index_map.len(), Vec3::ZERO);
                face_indices.iter().flatten().zip(normals.iter()).for_each(|(&vert_index, normal)| {
                    new_normals[vert_index] = *normal;
                });

                Some(Vertex(new_normals))
            }
            else {
                self.normals
            }
        };
        
        let mut verts = Vec::with_capacity(index_map.len());
        verts.resize(index_map.len(), Vec3::ZERO);

        index_map.into_iter().for_each(|(vert, i)| {
            verts[i] = vert.vec3();
        });

        return IndexedMesh {
            verts,
            faces: face_indices,
            normals,
        };
    }

    pub fn write_obj_to_file(&self, filename: impl AsRef<Path>)
    {
        let mut file = BufWriter::new(File::create(filename).unwrap());
        writeln!(file, "# Mesh generated by rusty_ground\n# UnindexedMesh").unwrap();
        self.faces.iter().flatten().for_each(|&vert| {
            writeln!(file, "v {} {} {}", vert.x, vert.y, vert.z).unwrap();
        });

        writeln!(file).unwrap();

        if let Some(normals) = &self.normals {
            use Normals::*;
            match &normals {
                Face(_) => writeln!(file, "# Normals: Face").unwrap(),
                Vertex(_) => writeln!(file, "# Normals: Vertex").unwrap(),
            }
            let (Vertex(normals) | Face(normals)) = normals;
            normals.iter().for_each(|&normal| {
                writeln!(file, "vn {} {} {}", normal.x, normal.y, normal.z).unwrap();
            });
            writeln!(file).unwrap();
        }
        else
        {
            writeln!(file, "# Normals: None\n").unwrap();
        }
        
        let face_iter = (0..self.faces.len())
            .map(|x| ((x*3)+1, (x*3)+2, (x*3)+3))
            .enumerate();

        match self.normals {
            Some(Normals::Face(_)) => {
                face_iter.for_each(|(i, face)| {
                    writeln!(file, "f {}//{3} {}//{3} {}//{3}",
                            face.0,
                            face.1,
                            face.2,
                            i+1
                        ).unwrap();
                });
            },
            Some(Normals::Vertex(_)) => {
                face_iter.for_each(|(_, face)| {
                    writeln!(file, "f {0}//{0}, {1}//{1}, {2}//{2}",
                            face.0,
                            face.1,
                            face.2,
                        ).unwrap();
                });
            },
            None => {
                face_iter.for_each(|(_, face)| {
                    writeln!(file, "f {} {} {}", face.0, face.1, face.2).unwrap()
                })
            }
        }
    }
}

impl IndexedMesh {
    pub fn write_obj_to_file(&self, filename: impl AsRef<Path>)
    {
        let mut file = BufWriter::new(File::create(filename).unwrap());
        writeln!(file, "# Mesh generated by rusty_ground\n# IndexedMesh").unwrap();
        self.verts.iter().for_each(|&vert| {
            writeln!(file, "v {} {} {}", vert.x, vert.y, vert.z).unwrap();
        });

        writeln!(file).unwrap();

        if let Some(normals) = &self.normals {
            use Normals::*;
            match &normals {
                Face(_) => writeln!(file, "# Normals: Face").unwrap(),
                Vertex(_) => writeln!(file, "# Normals: Vertex").unwrap(),
            }
            let (Vertex(normals) | Face(normals)) = normals;
            normals.iter().for_each(|&normal| {
                writeln!(file, "vn {} {} {}", normal.x, normal.y, normal.z).unwrap();
            });
            writeln!(file).unwrap();
        }
        else
        {
            writeln!(file, "# Normals: None\n").unwrap();
        }
        
        let face_iter = self.faces.iter().enumerate();

        match self.normals {
            Some(Normals::Face(_)) => {
                face_iter.for_each(|(i, face)| {
                    writeln!(file, "f {}//{3} {}//{3} {}//{3}",
                            face[0]+1,
                            face[1]+1,
                            face[2]+1,
                            i+1
                        ).unwrap();
                });
            },
            Some(Normals::Vertex(_)) => {
                face_iter.for_each(|(_, face)| {
                    writeln!(file, "f {0}//{0}, {1}//{1}, {2}//{2}",
                            face[0]+1,
                            face[1]+1,
                            face[2]+1,
                        ).unwrap();
                });
            },
            None => {
                face_iter.for_each(|(_, face)| {
                    writeln!(file, "f {} {} {}", face[0]+1, face[1]+1, face[2]+1).unwrap()
                })
            }
        }
    }
}